# 私有化 Cargo
## Git支持
一般在组织内总有一些内部封装的模块代码, Cargo则类似golang一样提供一种git方式的[支持](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories).

```toml Cargo.toml
[dependencies]
regex = { git = "https://github.com/rust-lang/regex" } 
```

### git对文件下载类型支持:
- branch (Exp:```regex = { git = "https://github.com/rust-lang/regex", branch = "next" } ```)
- tag (Exp: ```regex = { git = "https://github.com/rust-lang/regex", tag = "0.3.1" } ```)
- rev (Exp: ```regex = { git = "https://github.com/rust-lang/regex", tag = "0.3.1" } ```)
- version,在本地的时候用本地的,发布的时候用版本0.3.1 (Exp: ```regex = { git = "https://github.com/rust-lang/regex", version = "0.3.1" } ```)

#### Bitflags
`Bitflags` 是一个 Rust crate（也可以理解为一个 Rust 的库或模块），用于创建可以方便地进行按位操作的标志位。
在 Rust 中，一个 `bitflag` 是由多个二进制位组成的数值，每个二进制位代表一个标志位。使用这些标志位，可以表示一个开关状态、一组选项或者其他一些可以被二进制位表达的值。
通过使用 `bitflags` crate，可以轻松地定义和操作这些标志位。该 crate 提供了一组宏，可以定义一个 `bitflag` 枚举类型，并为该类型添加各种操作符和方法，以便进行按位操作。
例如，以下代码演示了如何定义一个 `bitflag` 枚举类型，并使用其中的标志位进行按位操作:
```rust 
use bitflags::bitflags;

bitflags! {
    struct MyFlags: u32 {
        const FLAG_A = 0b00000001;
        const FLAG_B = 0b00000010;
        const FLAG_C = 0b00000100;
        const FLAG_D = 0b00001000;
    }
}

fn main() {
    let flags = MyFlags::FLAG_A | MyFlags::FLAG_B;
    assert!(flags.contains(MyFlags::FLAG_A));
    assert!(flags.contains(MyFlags::FLAG_B));
    assert!(!flags.contains(MyFlags::FLAG_C));
    assert!(!flags.contains(MyFlags::FLAG_D));
}

```
在上面的示例中，我们定义了一个 MyFlags 枚举类型，其包含四个标志位：`FLAG_A`、`FLAG_B`、`FLAG_C` 和 `FLAG_D`。每个标志位都表示为二进制数，使用 `bitflags`! 宏进行定义。在 main() 函数中，我们创建了一个名为 flags 的变量，将其中包含的标志位设置为 `FLAG_A` 和 `FLAG_B`。我们然后使用 contains() 方法检查变量中是否包含指定的标志位，并使用断言（assert）来确保测试通过。

## 自定义
### [Nexus支持: Nexus Repository Cargo Format](https://github.com/sonatype-nexus-community/nexus-repository-cargo)
### [Cargo.io](https://github.com/rust-lang/crates.io)